-- Firebird Datenmodell für Timetracking-App
-- ===========================================

-- Tabelle für Teams
CREATE TABLE TEAMS (
    TEAM_ID INTEGER NOT NULL,
    TEAM_NAME VARCHAR(100) NOT NULL UNIQUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    IS_ACTIVE CHAR(1) DEFAULT 'Y' CHECK (IS_ACTIVE IN ('Y', 'N')),
    CONSTRAINT PK_TEAMS PRIMARY KEY (TEAM_ID)
);

-- Generator für Team-IDs
CREATE GENERATOR GEN_TEAM_ID;

-- Trigger für automatische Team-ID-Vergabe
SET TERM ^^ ;
CREATE TRIGGER TR_TEAMS_BI FOR TEAMS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.TEAM_ID IS NULL) THEN
        NEW.TEAM_ID = GEN_ID(GEN_TEAM_ID, 1);
END^^
SET TERM ; ^^

-- Tabelle für Benutzer
CREATE TABLE USERS (
    USER_ID INTEGER NOT NULL,
    USERNAME VARCHAR(50) NOT NULL UNIQUE,
    EMAIL VARCHAR(100) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(50),
    LAST_NAME VARCHAR(50),
    ADDRESS VARCHAR(255),
    TEAM_ID INTEGER,
    IS_TEAM_ADMIN CHAR(1) DEFAULT 'N' CHECK (IS_TEAM_ADMIN IN ('Y', 'N')),
    IS_CONFIRMED CHAR(1) DEFAULT 'N' CHECK (IS_CONFIRMED IN ('Y', 'N')),
    CONFIRMATION_TOKEN VARCHAR(255),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LAST_LOGIN TIMESTAMP,
    IS_ACTIVE CHAR(1) DEFAULT 'Y' CHECK (IS_ACTIVE IN ('Y', 'N')),
    CONSTRAINT PK_USERS PRIMARY KEY (USER_ID),
    CONSTRAINT FK_USERS_TEAM FOREIGN KEY (TEAM_ID) REFERENCES TEAMS (TEAM_ID)
);

-- Generator für User-IDs
CREATE GENERATOR GEN_USER_ID;

-- Trigger für automatische User-ID-Vergabe
SET TERM ^^ ;
CREATE TRIGGER TR_USERS_BI FOR USERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.USER_ID IS NULL) THEN
        NEW.USER_ID = GEN_ID(GEN_USER_ID, 1);
END^^
SET TERM ; ^^

-- Tabelle für Einladungslinks
CREATE TABLE TEAM_INVITATIONS (
    INVITATION_ID INTEGER NOT NULL,
    TEAM_ID INTEGER NOT NULL,
    INVITED_BY_USER_ID INTEGER NOT NULL,
    INVITATION_TOKEN VARCHAR(255) NOT NULL UNIQUE,
    EMAIL VARCHAR(100) NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    EXPIRES_AT TIMESTAMP NOT NULL,
    IS_USED CHAR(1) DEFAULT 'N' CHECK (IS_USED IN ('Y', 'N')),
    USED_AT TIMESTAMP,
    USED_BY_USER_ID INTEGER,
    CONSTRAINT PK_TEAM_INVITATIONS PRIMARY KEY (INVITATION_ID),
    CONSTRAINT FK_INVITATIONS_TEAM FOREIGN KEY (TEAM_ID) REFERENCES TEAMS (TEAM_ID),
    CONSTRAINT FK_INVITATIONS_INVITER FOREIGN KEY (INVITED_BY_USER_ID) REFERENCES USERS (USER_ID),
    CONSTRAINT FK_INVITATIONS_USER FOREIGN KEY (USED_BY_USER_ID) REFERENCES USERS (USER_ID)
);

-- Generator für Invitation-IDs
CREATE GENERATOR GEN_INVITATION_ID;

-- Trigger für automatische Invitation-ID-Vergabe
SET TERM ^^ ;
CREATE TRIGGER TR_TEAM_INVITATIONS_BI FOR TEAM_INVITATIONS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.INVITATION_ID IS NULL) THEN
        NEW.INVITATION_ID = GEN_ID(GEN_INVITATION_ID, 1);
END^^
SET TERM ; ^^

-- Tabelle für Projekte
CREATE TABLE PROJECTS (
    PROJECT_ID INTEGER NOT NULL,
    PROJECT_NAME VARCHAR(100) NOT NULL,
    DESCRIPTION VARCHAR(500),
    CLIENT_NAME VARCHAR(100),
    TEAM_ID INTEGER,
    CREATED_BY_USER_ID INTEGER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    IS_ACTIVE CHAR(1) DEFAULT 'Y' CHECK (IS_ACTIVE IN ('Y', 'N')),
    CONSTRAINT PK_PROJECTS PRIMARY KEY (PROJECT_ID),
    CONSTRAINT FK_PROJECTS_TEAM FOREIGN KEY (TEAM_ID) REFERENCES TEAMS (TEAM_ID),
    CONSTRAINT FK_PROJECTS_USER FOREIGN KEY (CREATED_BY_USER_ID) REFERENCES USERS (USER_ID)
);

-- Generator für Project-IDs
CREATE GENERATOR GEN_PROJECT_ID;

-- Trigger für automatische Project-ID-Vergabe
SET TERM ^^ ;
CREATE TRIGGER TR_PROJECTS_BI FOR PROJECTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.PROJECT_ID IS NULL) THEN
        NEW.PROJECT_ID = GEN_ID(GEN_PROJECT_ID, 1);
END^^
SET TERM ; ^^

-- Tabelle für Zeiterfassung
CREATE TABLE TIME_ENTRIES (
    ENTRY_ID INTEGER NOT NULL,
    USER_ID INTEGER NOT NULL,
    PROJECT_ID INTEGER NOT NULL,
    ACTIVITY_DESCRIPTION VARCHAR(255) NOT NULL,
    START_TIME TIMESTAMP NOT NULL,
    END_TIME TIMESTAMP,
    TOTAL_MINUTES INTEGER,
    PAUSE_MINUTES INTEGER DEFAULT 0,
    IS_RUNNING CHAR(1) DEFAULT 'Y' CHECK (IS_RUNNING IN ('Y', 'N')),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    MODIFIED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT PK_TIME_ENTRIES PRIMARY KEY (ENTRY_ID),
    CONSTRAINT FK_TIME_ENTRIES_USER FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID),
    CONSTRAINT FK_TIME_ENTRIES_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS (PROJECT_ID),
    CONSTRAINT CHK_TIME_ENTRIES_TIMES CHECK (END_TIME IS NULL OR END_TIME >= START_TIME)
);

-- Generator für Time-Entry-IDs
CREATE GENERATOR GEN_TIME_ENTRY_ID;

-- Trigger für automatische Time-Entry-ID-Vergabe und Berechnung
SET TERM ^^ ;
CREATE TRIGGER TR_TIME_ENTRIES_BI FOR TIME_ENTRIES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.ENTRY_ID IS NULL) THEN
        NEW.ENTRY_ID = GEN_ID(GEN_TIME_ENTRY_ID, 1);
END^^

CREATE TRIGGER TR_TIME_ENTRIES_BU FOR TIME_ENTRIES
ACTIVE BEFORE UPDATE POSITION 0
AS
BEGIN
    NEW.MODIFIED_AT = CURRENT_TIMESTAMP;
    
    -- Berechnung der Gesamtminuten bei Beendigung
    IF (NEW.END_TIME IS NOT NULL AND OLD.END_TIME IS NULL) THEN
    BEGIN
        NEW.IS_RUNNING = 'N';
        NEW.TOTAL_MINUTES = DATEDIFF(MINUTE, NEW.START_TIME, NEW.END_TIME) - COALESCE(NEW.PAUSE_MINUTES, 0);
    END
END^^
SET TERM ; ^^

-- Tabelle für Pausenzeiten
CREATE TABLE TIME_PAUSES (
    PAUSE_ID INTEGER NOT NULL,
    ENTRY_ID INTEGER NOT NULL,
    PAUSE_START TIMESTAMP NOT NULL,
    PAUSE_END TIMESTAMP,
    PAUSE_MINUTES INTEGER,
    REASON VARCHAR(100),
    CONSTRAINT PK_TIME_PAUSES PRIMARY KEY (PAUSE_ID),
    CONSTRAINT FK_TIME_PAUSES_ENTRY FOREIGN KEY (ENTRY_ID) REFERENCES TIME_ENTRIES (ENTRY_ID) ON DELETE CASCADE,
    CONSTRAINT CHK_TIME_PAUSES_TIMES CHECK (PAUSE_END IS NULL OR PAUSE_END >= PAUSE_START)
);

-- Generator für Pause-IDs
CREATE GENERATOR GEN_PAUSE_ID;

-- Trigger für automatische Pause-ID-Vergabe und Berechnung
SET TERM ^^ ;
CREATE TRIGGER TR_TIME_PAUSES_BI FOR TIME_PAUSES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.PAUSE_ID IS NULL) THEN
        NEW.PAUSE_ID = GEN_ID(GEN_PAUSE_ID, 1);
END^^

CREATE TRIGGER TR_TIME_PAUSES_BU FOR TIME_PAUSES
ACTIVE BEFORE UPDATE POSITION 0
AS
BEGIN
    -- Berechnung der Pausenminuten bei Beendigung der Pause
    IF (NEW.PAUSE_END IS NOT NULL AND OLD.PAUSE_END IS NULL) THEN
    BEGIN
        NEW.PAUSE_MINUTES = DATEDIFF(MINUTE, NEW.PAUSE_START, NEW.PAUSE_END);
    END
END^^

-- Trigger zur Aktualisierung der Gesamtpausenzeit in TIME_ENTRIES
CREATE TRIGGER TR_TIME_PAUSES_AU FOR TIME_PAUSES
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
    -- Aktualisierung der Pausenminuten in der Haupttabelle
    IF (NEW.PAUSE_MINUTES IS NOT NULL AND OLD.PAUSE_MINUTES IS NULL) THEN
    BEGIN
        UPDATE TIME_ENTRIES 
        SET PAUSE_MINUTES = (
            SELECT COALESCE(SUM(PAUSE_MINUTES), 0) 
            FROM TIME_PAUSES 
            WHERE ENTRY_ID = NEW.ENTRY_ID AND PAUSE_MINUTES IS NOT NULL
        )
        WHERE ENTRY_ID = NEW.ENTRY_ID;
    END
END^^
SET TERM ; ^^

-- Indizes für bessere Performance
CREATE INDEX IDX_USERS_TEAM ON USERS (TEAM_ID);
CREATE INDEX IDX_USERS_EMAIL ON USERS (EMAIL);
CREATE INDEX IDX_USERS_USERNAME ON USERS (USERNAME);
CREATE INDEX IDX_PROJECTS_TEAM ON PROJECTS (TEAM_ID);
CREATE INDEX IDX_TIME_ENTRIES_USER ON TIME_ENTRIES (USER_ID);
CREATE INDEX IDX_TIME_ENTRIES_PROJECT ON TIME_ENTRIES (PROJECT_ID);
CREATE INDEX IDX_TIME_ENTRIES_START_TIME ON TIME_ENTRIES (START_TIME);
CREATE INDEX IDX_TIME_ENTRIES_RUNNING ON TIME_ENTRIES (IS_RUNNING);
CREATE INDEX IDX_TIME_PAUSES_ENTRY ON TIME_PAUSES (ENTRY_ID);
CREATE INDEX IDX_INVITATIONS_TOKEN ON TEAM_INVITATIONS (INVITATION_TOKEN);
CREATE INDEX IDX_INVITATIONS_TEAM ON TEAM_INVITATIONS (TEAM_ID);

-- Views für häufige Abfragen
CREATE VIEW V_ACTIVE_TIME_ENTRIES AS
SELECT 
    te.ENTRY_ID,
    te.USER_ID,
    u.USERNAME,
    u.FIRST_NAME,
    u.LAST_NAME,
    te.PROJECT_ID,
    p.PROJECT_NAME,
    p.CLIENT_NAME,
    te.ACTIVITY_DESCRIPTION,
    te.START_TIME,
    te.TOTAL_MINUTES,
    te.PAUSE_MINUTES,
    DATEDIFF(MINUTE, te.START_TIME, CURRENT_TIMESTAMP) - COALESCE(te.PAUSE_MINUTES, 0) AS CURRENT_MINUTES
FROM TIME_ENTRIES te
JOIN USERS u ON te.USER_ID = u.USER_ID
JOIN PROJECTS p ON te.PROJECT_ID = p.PROJECT_ID
WHERE te.IS_RUNNING = 'Y';

-- View für Zeitreports
CREATE VIEW V_TIME_REPORT AS
SELECT 
    te.ENTRY_ID,
    te.USER_ID,
    u.USERNAME,
    u.FIRST_NAME,
    u.LAST_NAME,
    u.TEAM_ID,
    t.TEAM_NAME,
    te.PROJECT_ID,
    p.PROJECT_NAME,
    p.CLIENT_NAME,
    te.ACTIVITY_DESCRIPTION,
    te.START_TIME,
    te.END_TIME,
    te.TOTAL_MINUTES,
    te.PAUSE_MINUTES,
    CAST(te.START_TIME AS DATE) AS WORK_DATE
FROM TIME_ENTRIES te
JOIN USERS u ON te.USER_ID = u.USER_ID
LEFT JOIN TEAMS t ON u.TEAM_ID = t.TEAM_ID
JOIN PROJECTS p ON te.PROJECT_ID = p.PROJECT_ID
WHERE te.IS_RUNNING = 'N';

-- Rollen und Berechtigungen (optional)
-- CREATE ROLE TIMETRACK_USER;
-- CREATE ROLE TIMETRACK_ADMIN;
-- GRANT SELECT, INSERT, UPDATE ON TIME_ENTRIES TO TIMETRACK_USER;
-- GRANT ALL ON ALL TO TIMETRACK_ADMIN;